(define-library (scm-check check-component cond)
  (import (scheme base)
          (scheme write)
          (only (srfi 1) every any remove)
          (prefix (scm-check code-warning) w/)
          (prefix (scm-check reader) schk-rdr/))
  (export check-cond)
  (begin
    (define (else-clause? clause)
      (eq? (car clause) 'else))

    (define (quote-symbol-expression? expression)
      (and (list? expression)
           (eq? (car expression) 'quote)
           (symbol? (cadr expression))))

    (define (atom-except-identifier? object)
      (or (integer? object)
          (char? object)
          (boolean? object)))

    ;;TODO: Support non symbol data.
    (define (check-atom-eq-clause clause)
      (let* ((test (car clause))
             (test-ope (and (list? test) (car test))))
        (or (and (eq? test-ope 'zero?)
                 (cons (cadr test) 0))
            (and test-ope
                 (or (eq? test-ope 'eq?)
                     (eq? test-ope 'eqv?)
                     (eq? test-ope '=)
                     (eq? test-ope 'boolean=?)
                     (eq? test-ope 'char=?))
                 (or (and (or (quote-symbol-expression? (cadr test))
                              (atom-except-identifier? (cadr test)))
                          (cons (list-ref test 2)
                                (if (quote-symbol-expression? (cadr test))
                                  (cadr (cadr test))
                                  (cadr test))))
                     (and (or (quote-symbol-expression? (list-ref test 2))
                              (atom-except-identifier? (list-ref test 2)))
                          (cons (cadr test)
                                (if (quote-symbol-expression? (list-ref test 2))
                                  (cadr (list-ref test 2))
                                  (list-ref test 2)))))))))

    (define (simple-clause? clause)
      (and (list? clause)
           (or (else-clause? clause)
               (and (>= (length clause) 2)
                    (not (eq? (cadr clause) '=>))))))

    (define (all-same? ls)
      (or (null? ls)
          (null? (cdr ls))
          (let loop ((ls* (cdr ls)))
            (cond
              ((null? ls*) #t)
              ((equal? (car ls*) (car ls))
               (loop (cdr ls*)))
              (else #f)))))

    (define (check-cond->case-pattern code debug-info)
      (let* ((clauses (cdr code)))
        (if (every simple-clause? clauses)
          (let ((check-res (map check-atom-eq-clause
                                 (remove else-clause? clauses))))
            (if (and (not (any (lambda (x) (eq? x #f)) check-res))
                     (all-same? (map car check-res)))
              (w/make-code-warning debug-info
                                   "Use case.")
              #f))
          #f)))

    (define (check-cond code debug-info)
      (let ((resp (check-cond->case-pattern code debug-info)))
        (if resp
          (list resp)
          '())))))
